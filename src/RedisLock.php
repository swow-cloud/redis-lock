<?php
/**
 * This file is part of SwowCloud
 *
 * @license  https://github.com/swow-cloud/websocket-server/blob/main/LICENSE
 */

/* @noinspection PhpMemberCanBePulledUpInspection */

declare(strict_types=1);

namespace SwowCloud\RedisLock;

use Hyperf\Contract\ConfigInterface;
use Hyperf\Contract\StdoutLoggerInterface;
use Hyperf\Engine\Coroutine as SwowCo;
use Hyperf\Redis\Redis;
use Hyperf\Redis\RedisFactory;
use InvalidArgumentException;
use Psr\Container\ContainerExceptionInterface;
use Psr\Container\ContainerInterface;
use Psr\Container\NotFoundExceptionInterface;
use Ramsey\Uuid\Uuid;
use Swow\Coroutine;
use SwowCloud\RedisLock\Contract\LockInterface;
use Throwable;

class RedisLock implements LockInterface
{
    private string $pool;

    /**
     * the lock key
     */
    private string $key = '';

    /**
     * the unique id generated by the current coroutine
     */
    protected string $value = '';

    /**
     * the lock key's lifetime
     */
    private int $ttl;

    private ContainerInterface $container;

    private StdoutLoggerInterface $logger;

    /**
     * redis lock config.
     */
    private array $config;

    /**
     * @param ContainerInterface $container
     *
     * @throws ContainerExceptionInterface
     * @throws NotFoundExceptionInterface
     */
    public function __construct(ContainerInterface $container)
    {
        $this->container = $container;
        if (!$this->container->has(StdoutLoggerInterface::class)) {
            throw new InvalidArgumentException('StdoutLogger not found#');
        }
        if (!$config = $this->container->get(ConfigInterface::class)->get('redis_lock')) {
            throw new InvalidArgumentException('redis lock configuration not found#');
        }
        $this->config = $config;
        $this->pool = $this->config['pool'] ?? 'default';
        $this->logger = $this->container->get(StdoutLoggerInterface::class);
    }

    public function tryLock(string $key, int $ttl = 3): bool
    {
        $this->value = Uuid::uuid4()->toString();

        return $this->doLock($key, $ttl);
    }

    public function lock(string $key, int $ttl = 3, int $retries = 3, int $usleep = 10000): bool
    {
        $lock = false;
        $retryTimes = max($retries, 1);
        while ($retryTimes-- > 0) {
            $this->value = Uuid::uuid4()->toString();
            $lock = $this->doLock($key, $ttl);
            if ($lock) {
                break;
            }
            usleep($usleep);
            $this->logger->debug(
                sprintf('Try to acquire the lock again, the number of attempts: %s,Key: %s', $retryTimes, $key)
            );
        }

        return $lock;
    }

    public function unLock(): bool
    {
        $script = <<<'LUA'
            local key = KEYS[1]
            local value = ARGV[1]

            if (redis.call('exists', key) == 1 and redis.call('get', key) == value)
            then
                return redis.call('del', key)
            end

            return 0
LUA;

        return (bool)$this->execLuaScript($script, [$this->key, $this->value], 1);
    }

    public function lockTtl(): int
    {
        return $this->ttl;
    }

    /**
     * @throws \Throwable
     */
    public function keepAlive(int $ttl = 3): bool
    {
        $script = <<<'LUA'
                -- get the remaining life time of the key
                local leftoverTtl = redis.call("TTL", KEYS[1]);

                -- never expired key
                if (leftoverTtl == -1) then
                    return -1;
                end;

                -- key with remaining time
                if (leftoverTtl ~= -2) then
                    return redis.call("EXPIRE", KEYS[1], ARGV[1]);
                end;

                -- key that does not exist
                return -2;
LUA;

        try {
            $eval = $this->execLuaScript($script, [$this->key, $ttl], 1);

            return $eval !== -2;
        } catch (Throwable $e) {
            $this->logger->error(format_throwable($e));
            throw $e;
        }
    }

    /**
     * @throws \Throwable
     */
    public function isAlive(): bool
    {
        if (!$this->key) {
            return false;
        }

        try {
            $eval = $this->getConnection()->get($this->key);

            return $eval === $this->value;
        } catch (Throwable $e) {
            $this->logger->error(format_throwable($e));
            throw $e;
        }
    }

    /**
     * @param $key
     * @param $ttl
     *
     * @return bool
     * @throws Throwable
     */
    protected function doLock($key, $ttl): bool
    {
        $script = <<<'LUA'
            local key = KEYS[1]
            local value = ARGV[1]
            local ttl = ARGV[2]

            if (redis.call('setnx', key, value) == 1) then
                return redis.call('expire', key, ttl)
            elseif (redis.call('ttl', key) == -1) then
                return redis.call('expire', key, ttl)
            end

            return 0
LUA;
        $this->ttl = $ttl;
        $this->key = $key;

        try {
            $result = $this->execLuaScript($script, [$key, $this->value, $ttl], 1);
            if ($result) {
                $this->logger->debug(
                    sprintf(
                        'coroutine[%s] successfully hold lock[uuid:%s,key:%s], initialize the watchdog',
                        Coroutine::getCurrent()->getId(),
                        $this->value,
                        $this->key
                    )
                );
                SwowCo::create(function () {
                    $watchdog = make(WatchDog::class);
                    $watchdog->sentinel($this, $this->config['watchDogTime'] ?? 60);
                });
            }

            return (bool)$result;
        } catch (Throwable $exception) {
            $this->logger->error(format_throwable($exception));
            throw $exception;
        }
    }

    /**
     * @throws ContainerExceptionInterface
     * @throws Throwable
     * @throws NotFoundExceptionInterface
     */
    protected function getConnection(): Redis
    {
        try {
            return $this->container->get(RedisFactory::class)->get($this->pool);
        } catch (Throwable $exception) {
            $this->logger->error($exception->getMessage());
            throw $exception;
        }
    }

    /**
     * @param string $script
     * @param array  $args
     * @param int    $number
     *
     * @return mixed
     * @throws ContainerExceptionInterface
     * @throws NotFoundExceptionInterface
     * @throws Throwable
     * @throws \RedisException
     */
    private function execLuaScript(string $script, array $args, int $number = 0): mixed
    {
        $redis = $this->getConnection();

        return $redis->evalSha($redis->script('load', $script), $args, $number);
    }
}
